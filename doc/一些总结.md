## 为什么要造个脚本语言
- 实践想法：学习工作中接触各种编程语言，使用中会有不顺手的地方：语法别扭、缺少功能、容易写错、工具不好用、复杂臃肿等等。便有各种修改语言的想法，然后只能空想。如果自己实现个，自己控制，能实现验证各种思路想法，不是很妙。
    - 要是能作为自己平时工具语言，就更好了。
- 提升水平：觉得实现编程语言是个了不得的成就，到那时编程水平应该很高。
    - 要是实现个广为使用的语言，如php、python一般，就更好了。

## 今后打算
个人精力有限，大概只能维护一个的弱类型脚本语言，如lua,js这般。然后后续的jit编译器，工具链，标准库，文档，也是很难吧。

ss实现到现在也到了个瓶颈。实现个强类型语言不现实，可以找个开源项目，看看实现，如c#和go。
至于ss，考虑慢慢完善各标准工具库，就可以平时当工具脚本用用了。也不浪费了。

可以看看anltr去。
暂时不知做什么好了。

## 一些零散的点，值得关注
- 垃圾回收
    - 优点：
        - 编程更快。【学习成本上一般来说是更低的，但深入理解的成本持平或高于C++。会有新的问题，像C#的析构函数和Dispose方法为啥那么写？】
        - 不容易出现野指针问题。
    - 缺点
        - 会有stop the world的暂停存在。一些特定情况下是致命的，比如实时同步游戏的同步逻辑里。
        - 不容易精确控制内存。
- 语法
    - 编译原理现在已经非常成熟，一般都在研究编译优化的东西。**不为大众熟知**
    - **创新点多在语法上，设计理念也在语法上体现。**
    - 关于语法的设计
        - 一个简单的设计讨论是，对于语句，都有一个特殊的命令关键字作开头，编写递归下降会很方便。
        - 有两类语句稍微留意：1. 赋值语句、2. 函数调用语句。
        - 区块符号注意下，`(),[],{},'',""`，这些成对出现。
    - 解析代码编写
        - 有像yacc/anltr这类的工具，可以自定生成解析代码
        - 不少书中说实际语言大多手写编译器前端部分，更加可控。一般使用递归下降加算符优先级分析法就可实现了。
    - **一个想法**，在同一份源码里使用多种语法解析器混合在一起，以同样的语法树作为输出目标。这样可以尝试各种类型的语法
- 并发编程
    - 常见的同步机制：锁、信号量、自旋锁
    - 语法支持：
        - c# await/async/Task/Thread
        - go go.goroutine/cha.channel【go还引进了个理念，**少用锁，多用channel传递数据**】
    - 协程
        - await一类的stackless协程
        - goroutine一类的fullStack协程
- 编译优化的一些名词
    - 死代码剔除、常量折叠、复制传播【这部分简单点】
    - 活性分析、DAG
    - 寄存器分配、指令调度
    - 窥孔优化、指令强度削弱
    - jit


## 理想的编程语言
最后看来要按用途来说，各有所长，难有大一统的。列一些点：
- 语法
    - 简洁易学。少量代码就可实现功能。
    - 易懂易维护。看代码文本就能知道大多信息：设计思路，作用域，可见性等。
- 功能强大
    - 特性丰富。【与简洁易学矛盾】
        - 多态分发，方便模块设计。面向对象的多态，可以减少很多判断的代码。
        - 支持多线程编程。c#和go这方面比较好。
        - auto gc。
    - 可以精细控制。【与gc矛盾】
        - 控制内存使用
        - 控制运行时间
    - 标准库功能丰富。
    - 跨平台。
    - 静态检测。分析源码就能发现潜在错误。
        - 强类型语言这方面天然有优势。但是写代码必须各种定义编写类型/
        - 弱类型语言这方便差了很多，但写的随意。
- 性能强大【与功能强大略矛盾】
    - 运行速度快
    - 内存消耗少
    - *功耗小*
- 工具强大
    - 编辑
        - 智能提示。
        - 自动格式化。
    - 调试
        - 远程调试。
    - 分析
        - 监控运行时状态
        - 错误现场分析
- 文档完善。一般语言类似《Effect XX》的书，算是最佳实践。