## 2017-02-15
代码生成是寄存器分配整体是基于栈的，基于栈的指令可以非常简单，如零地址指令。
零地址指令系统，需要许多的push,pop指令来操作栈。
并且push/pop类的指令需要寄存器地址，要么在指令数组里插入数字，要么变长指令，都不理想。

想精简下指令来着
1. 支持更多局部变量，地址位数尽可能多。
2. 指令定长，且中间不包含特殊的数字。
开始歪歪成成单地址指令。
但是：
1. jump指令需要常数确定跳转距离。
2. move指令需要2个非连续的寄存器。
3. set_table、add等指令最好是三寄存器。

最终还是沿用luna的三地址指令。
也许哪天可以把指定定义成64位的。这样可以有6万多个局部变量了。

## 2017-02-09
在考虑如何处理语义解析和代码生成。
感觉luna的visitor使用的不好。
准备：
1. 语义分析合并到语法解析里。
2. 代码生成返回个Function静态结构。

## 2017-02-05
调整了下表达式语法限制。
语法解析部分完结，开始语义分析和代码生成。

回顾下
1. LL(2)递归下降解析中没有用到Follow集合。
2. 实际不算LL(2)文法，为了区分assgin-satement和funccall，
   使用了特殊写法，向后解析了很多单词，在尾部语法结构出判断的。
   PS:也可以延后到语义解析部分处理，那样就是标准的LL(2)文法了。

## 2017-02-03
语法解析测试完。

赋值语句与普通表达式的处理不够好，也就是代码中的ParseOtherStatement不够好，再想想。

## 2017-02-01
码完语法解析，准备写测试。
语法分析里的表达式分析用到算符有限算法和栈结构。

## 2017-01-30
开始写语法解析，递归下降解析，有luna做参考，还是挺简单的。差不多一个语法结构一个函数。

## 2017-01-29
定义语法树结构

## 2017-01-28
加了个简单测试框架。准备写语法解析部分。

## 2017-01-27
词法解析初版写好了，准备加单元测试代码。

词法部分接近标准的正则文法，可以通过读取前缀确定是什么单词。
多数只要读第一个字符就能确定。其中数字、字符串、注释的部分要特殊处理下。


## 2017-01-25
先写好词法解析，并且仿照luna写个简单的单元测试。


