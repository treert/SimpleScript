
-----------------simple script-------------------------
## 2017-07-23
目前缺少的：
1. 原型机制【大概没想象的重要的吧，到现在也没想过实现；考虑到Table和IUserData很像，用空再看看】
2. 调试功能【看看容不容易使用c#在vscode的上实现】

PS：感觉静态语言更好学些，一般编辑器可以很方便的提示。

## 2017-07-21
准备使用反射，实现c#扩展ss

大概要支持：
1. 类型注入
2. 静态函数调用
3. 创建对象
4. 读写对象属性或字段
5. 调用对象方法
6. c#调用lua回调函数。【没找到方便的方法生成特定Type的Delegate，不处理了】

## 2017-07-05
决定完善到能用于Unity热更新的地步。
【add】添加上了序列号功能
【opt】优化了下调用的接口，删掉旧的文件

后续（前一次也是这么说）：
- 错误提示，定位到行
- Table结构优化
- 提供类似tolua的工具，方便使用c#扩展ss

## 2017-06-30
又把闭包支持加回来了。
不打算放弃掉，继续完善，可用于Unity热更新之类的。
后续：
- 错误提示，定位到行
- Table结构优化
- 提供类似tolua的工具，方便使用c#扩张ss

## 2017-06-24
心情不好，完善下脚本。因为有之前的结构，修改挺容易的。
打算：先简化下，在完善到个人可用的程度，称为simple script。
还是要感叹下，完善起来不易。

之前有个体会：写业务代码时，异常不要处理，抛出相关信息就行。编程的方向是让异常不要发生，因为为异常写的代码不带来价值，有价值是正常的处理流程。
但是脚本语言不行哎：1. 任何输入都要能处理 2. 错误提示需要较复杂的信息。

心情好，维护点；心情不好维护点。

后续：
- 错误提示
- Table结构完善
------------------one more script-----------------------

## 2017-03-06
实现了协程。本次暂时告于断落。
去写几个blog去。

## 2017-03-05
0.1版本完成。可以实现简单的计算器了。
后面有两件事：
1. 按自己的想法实现下协程。
2. 写几篇blog。

代码越来越糟糕啊~~维护个脚本语言不容易啊。

## 2017-02-22
先能简单运行个计算器。
实现`local a = 1+2; print(a);`

虚拟机分两部分：管理资源，执行指令。

执行指令部分：
协程，所有协程共享一个虚拟机，同时只有一个工作。
1. 运行栈：局部变量栈，函数调用栈。
2. 状态机：stop，runing，finish，error。

管理资源部分：
1. 加载解析源代码。
2. 管理所有的协程：每次执行生成一个协程（有些浪费，最好不要在CFunction里又执行新的虚拟机命令）。
3. 管理对象生命周期：垃圾回收，对象池什么的。

## 2017-02-21
代码生成完成，下面写虚拟机执行那部分。
单元测试写起来好像很麻烦呀，
要是写就是判断生成的代码是否正确了。

## 2017-02-18
语义分析还是放到代码生成部分比较简单。
1. 作用域树维护，变量作用域判断
2. 循环中跳转范围判断处理
3. 读写区分
4. 返回值个数设置（现在在语法解析里，下次提出来）

## 2017-02-15
代码生成是寄存器分配整体是基于栈的，基于栈的指令可以非常简单，如零地址指令。
零地址指令系统，需要许多的push,pop指令来操作栈。
并且push/pop类的指令需要寄存器地址，要么在指令数组里插入数字，要么变长指令，都不理想。

想精简下指令来着
1. 支持更多局部变量，地址位数尽可能多。
2. 指令定长，且中间不包含特殊的数字。
开始歪歪成成单地址指令。
但是：
1. jump指令需要常数确定跳转距离。
2. move指令需要2个非连续的寄存器。
3. set_table、add等指令最好是三寄存器。

最终还是沿用luna的三地址指令。
也许哪天可以把指定定义成64位的。这样可以有6万多个局部变量了。

## 2017-02-09
在考虑如何处理语义解析和代码生成。
感觉luna的visitor使用的不好。
准备：
1. 语义分析合并到语法解析里。
2. 代码生成返回个Function静态结构。

## 2017-02-05
调整了下表达式语法限制。
语法解析部分完结，开始语义分析和代码生成。

回顾下
1. LL(2)递归下降解析中没有用到Follow集合。
2. 实际不算LL(2)文法，为了区分assgin-satement和funccall，
   使用了特殊写法，向后解析了很多单词，在尾部语法结构出判断的。
   PS:也可以延后到语义解析部分处理，那样就是标准的LL(2)文法了。

## 2017-02-03
语法解析测试完。

赋值语句与普通表达式的处理不够好，也就是代码中的ParseOtherStatement不够好，再想想。

## 2017-02-01
码完语法解析，准备写测试。
语法分析里的表达式分析用到算符有限算法和栈结构。

## 2017-01-30
开始写语法解析，递归下降解析，有luna做参考，还是挺简单的。差不多一个语法结构一个函数。

## 2017-01-29
定义语法树结构

## 2017-01-28
加了个简单测试框架。准备写语法解析部分。

## 2017-01-27
词法解析初版写好了，准备加单元测试代码。

词法部分接近标准的正则文法，可以通过读取前缀确定是什么单词。
多数只要读第一个字符就能确定。其中数字、字符串、注释的部分要特殊处理下。


## 2017-01-25
先写好词法解析，并且仿照luna写个简单的单元测试。


